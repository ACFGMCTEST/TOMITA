#include "CXCharPlayer.h"
#include "windows.h"
#include "../../../../Key/CKey.h"
#include "../CSceneModel.h"
#include "../../../../../Define/Define.h"
#include "../../Map/CMap.h"
#include "../../../../Key/CMouse.h"
#include "../../../../Convenient/CConvenient.h"
#include "../../../GameScene/Map/CMap.h"
#include "../../../ItemScene/CItem.h"
#include <math.h>
#include "../../../../Collision/CCollisionManager.h"
#include "../../../../Collision/CCollision.h"
/*ステータス*/
#include "State\Attack\CStatePlayerAttack.h"
#include "State\Idling\CStatePlayeridling.h"
#include "State\Jump\CStatePlayerJump.h"
#include "State\Run\CStatePlayerRun.h"
#include "State\RunAttack\CStatePlayerRunAttack.h"
/*当たり判定*/
#include "../../../../Collision/ColType/CColCapsule.h"
#include "../../../../Collision/ColType/CColTriangle.h"

/*向き*/
#define FORWARD_JUMP  0.0f,1.0f,1.0f//ジャンプ

/*あたり判定の設定値*/
#define OBB_RADIUS 0.5f
/*胴*/
#define OBB_SPHERE_BODY_SIZE 0.4f
#define OBB_SPHERE_BODY_POS CVector3(0.0f,0.0f,0.0f)
#define COL_POS CVector3(0.0f, 1.5f, 0.0f), CVector3(0.0f, -0.9f, 0.0f)
/*武器*/
#define OBB_WEAPON_POS CVector3(0.0f,0.5f,0.0f)
#define OBB_WEAPON_SIZE CVector3(0.4f, 0.7f, 0.4f)
/*足*/
#define OBB_LEG_SIZE 0.3f
#define OBB_LEG_POS CVector3(0.0f,-1.0f,0.0f)

/*HPバーの設定値*/
#define HP_BAR_POS CVector3(mPosition.x,mPosition.y + 1.8f,mPosition.z)
#define HP_BAR_SIZE -0.4f, 0.4f, -0.1f, 0.0f

/*動きの回転する速さ*/
#define TURN_SPEED 10

CXCharPlayer::CXCharPlayer() : mVelocity(0.0f), mFlagKnockback(false), mRotCount(0),
mGravitTime(GRA_INIT_TIME_COUNT), mFlagJump(false), mAdjust()
{
	mForward = CVector3(FORWARD);
	mpParent = this;
};
/*
Init
モデルと衝突判定の設定を行う
*/
void CXCharPlayer::Init(CModelX *model) {
	mStateMachine = (std::make_unique<CStateMachine>());
	// 第一引数にステートの「登録名」
	// 第二引数でStateBaseを継承したクラスのshared_ptrオブジェクトを生成
	mStateMachine->Register(PL_STATE_ATTACK, std::make_shared<CStatePlayerAttack>(), this);
	mStateMachine->Register(PL_STATE_IDLING, std::make_shared<CStatePlayerIdling>(), this);
	mStateMachine->Register(PL_STATE_RUN, std::make_shared<CStatePlayerRun>(), this);
	mStateMachine->Register(PL_STATE_JUMP, std::make_shared<CStatePlayerJump>(), this);
	mStateMachine->Register(PL_STATE_RUN_ATTACK, std::make_shared<CStatePlayerRunAttack>(), this);
	// 最初のステートを登録名で指定
	mStateMachine->SetStartState(PL_STATE_IDLING);

	//モデルの設定
	CModelXS::Init(model);

	//カプセル　キャラクタ全体
	new CColCapsule(this, COL_POS, OBB_RADIUS, &mpCombinedMatrix[model->FindFrame("metarig_hips")->mIndex]);

	mPower = ATTACK_POWER;//攻撃力

	PosUpdate();
	mPrevPos = mPosition;
}




/*ポジションのアップデート関数*/
void CXCharPlayer::PosUpdate(){
	CMatrix44 rot_y, pos, matrix;
	//回転行列の作成
	rot_y.rotationY(mRotation.y);

	//移動行列を計算する
	pos.translate(mPosition);
	//回転移動行列を求める
	matrix = pos * rot_y;

	//頂点データの更新
	CModelXS::Update(matrix);
	mPrevPos = mPosition;
}

/*回転関数*/
void CXCharPlayer::PlusRot(float rot){

	mRotation.y += rot;//タス処理
	if (mRotation.y < 0){//回転値がマイナスなら
		mRotation.y = ANGLE_360 + mRotation.y;//３６０以内にとどめる
	}
	if (mRotation.y > ANGLE_360){//３６０以上の場合
		mRotation.y = mRotation.y + ANGLE_360;
	}
}
/*キャラクター回転差が小さい方向に回転する*/
int CXCharPlayer::MoveRotation(int angle){

	/*右回り*/
	int turnRight = angle - mRotation.y;
	/*過剰余剰*/
	LIMIT_ANGLE(turnRight);
	/*左回り*/
	int turnLeft = ANGLE_360 - turnRight;

	//printf("右回転:%d,左回転%d\n", turnRight, turnLeft);
	/*同じの場合 ||
	右に越えてしまう場合 ||
	左に越えてしまう場合 ||
	*/
	if (mRotation.y == angle ||
		mRotation.y <= angle && angle <= mRotation.y + TURN_SPEED ||
		mRotation.y - TURN_SPEED <= angle && angle <= mRotation.y){
		return angle;
	}
	/*右方向確認*/
	if (turnRight < turnLeft){
		return mRotation.y + TURN_SPEED;
	}
	/*方向確認*/
	else{
		return mRotation.y - TURN_SPEED;
	}


}


/*動くときの関数*/
void CXCharPlayer::PlayerMoveRot(){

	LIMIT_ANGLE(mRotation.y);

	if (CKey::push('A')){//左に移動
		mRotation.y = MoveRotation(((int)MainCamera.Rot().y + ANGLE_90) % 360);
	}
	if (CKey::push('D')){//右に移動
		mRotation.y = MoveRotation(((int)MainCamera.Rot().y + ANGLE_270) % 360);
	}

	if (CKey::push('W')){//前に移動

		mRotation.y = MoveRotation(((int)MainCamera.Rot().y) % 360);
		if (CKey::push('A')){//左に移動
			mRotation.y = MoveRotation(((int)MainCamera.Rot().y + ANGLE_45) % 360);
		}
		if (CKey::push('D')){//右に移動
			mRotation.y = MoveRotation(((int)MainCamera.Rot().y + ANGLE_315) % 360);
		}
	}

	if (CKey::push('S')){
		mRotation.y = MoveRotation(((int)MainCamera.Rot().y + ANGLE_180) % 360);
		if (CKey::push('A')){//左に移動
			mRotation.y = MoveRotation(((int)MainCamera.Rot().y + ANGLE_125) % 360);
		}
		if (CKey::push('D')){//右に移動
			mRotation.y = MoveRotation(((int)MainCamera.Rot().y + ANGLE_225) % 360);
		}
	}

	Move();//移動させる

}
/*動かすときの処理
forward = 方向設定
velocity = 力
*/
void CXCharPlayer::Move(){

	CMatrix44 rot_y, pos, matrix;
	CVector3 moveForward = mForward;//参照でいじれないので
	//回転行列の作成
	rot_y.rotationY(mRotation.y);
	///進行方向を計算
	moveForward = mForward * rot_y;
	//移動させる
	mPosition += moveForward * mVelocity;
}


/*重力*/
void CXCharPlayer::Gravity(){
	/*地面についていないなら*/
	mPosition.y -= GRAVITY(mGravitTime);
	mGravitTime += GRA_TIME_UP;//時間が経つ
}
/*グラウンドの設定*/
void CXCharPlayer::ColGround(){
	mGravitTime = GRA_INIT_TIME_COUNT;
	mFlagJump = false;//ジャンプ終了
}

/*更新処理*/
void CXCharPlayer::Update(){
	mAdjust = CVector3();
	mPrevPos = mPosition;
	Gravity();/*重力*/
	PosUpdate();//ポジションを更新
	/*ステータスマシン更新*/
	mStateMachine->Update();

}



/*Render*/
void CXCharPlayer::Render() {
	CModelXS::Render();
}

/*エフェクトの描画処理*/
void CXCharPlayer::BillboardRender(){
	CVector3 pos = HAMMER_EFFECT_POS;
	pos = pos * mpCombinedMatrix[mpModel->FindFrame("metarig_WeaponHandle")->mIndex];//マトリックスから

}

/*あたり判定の時に呼び出し*/
void CXCharPlayer::ColMove(int count, CVector3 Forward){
	if (count <= -1){//カウントがマイナスなら
		mVelocity = -KNOCK_BACK; //後ろ向きにする
		count *= -1;//プラスにする
	}
	else
	{
		mVelocity = -KNOCK_BACK;
	}
	mForward = Forward;
	mCountKnockBack = count;
}



void SetAdjust(CVector3 *s, const CVector3 &t) {
	//x
	if (s->x > 0) {
		if (t.x > 0) {
			if (s->x < t.x)
				s->x = t.x;
		}
		else {
			if (s->x < -t.x)
				s->x = t.x;
		}
	}
	else {
		if (t.x > 0) {
			if (-s->x < t.x)
				s->x = t.x;
		}
		else {
			if (-s->x < -t.x)
				s->x = t.x;
		}
	}
	//y
	if (s->y > 0) {
		if (t.y > 0) {
			if (s->y < t.y)
				s->y = t.y;
		}
		else {
			if (s->y < -t.y)
				s->y = t.y;
		}
	}
	else {
		if (t.y > 0) {
			if (-s->y < t.y)
				s->y = t.y;
		}
		else {
			if (-s->y < -t.y)
				s->y = t.y;
		}
	}
	//z
	if (s->z > 0) {
		if (t.z > 0) {
			if (s->z < t.z)
				s->z = t.z;
		}
		else {
			if (s->z < -t.z)
				s->z = t.z;
		}
	}
	else {
		if (t.z > 0) {
			if (-s->z < t.z)
				s->z = t.z;
		}
		else {
			if (-s->z < -t.z)
				s->z = t.z;
		}
	}
}

//m 自分　y 相手
bool CXCharPlayer::Collision(CColBase* m, CColBase* y) {
	//CColBase *m = (CColBase*)me;
	//CColBase *y = (CColBase*)you;
	/*自分のタイプが何か判断*/
	switch (m->mType) {

	case CColBase::COL_CAPSULE://自分の当たり判定がカプセルの場合
		CColCapsule *cc = (CColCapsule*)m;

		/*相手のタイプ何か判断*/
		switch (y->mType) {
			/*相手が三角の場合*/
		case CColBase::COL_TRIANGLE:
			CColTriangle ct = (*(CColTriangle*)y).GetUpdate();
			/*当たり判定計算*/
			if (CCollision::IntersectTriangleCapsule3(ct.mV[0], ct.mV[1], ct.mV[2],
				cc->mV[0], cc->mV[1], cc->mRadius, &cc->mAdjust)) {
				ColGround();//地面にあった時の処理
				SetAdjust(&mAdjust, cc->mAdjust);
				mPosition = mPosition + mAdjust;
				CMatrix44 rot_y, pos, matrix;
				//回転行列の作成
				rot_y.rotationY(mRotation.y);
				//移動行列を計算する
				pos.translate(mPosition);
				//回転移動行列を求める
				matrix = pos * rot_y;
				UpdateSkinMatrix(matrix);
			}
			break;

		};
		break;
	};

	return false;
}
